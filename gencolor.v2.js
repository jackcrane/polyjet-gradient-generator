const overallTimeStart = new Date();
const { createCanvas } = require("canvas");
const config = require("./config.json");
const fs = require("fs");
const importTime = new Date();
const child_process = require("child_process");

const LOCAL_HAS_CHANGES =
  child_process.execSync("git diff --name-only").toString() !== "" ||
  child_process
    .execSync("git ls-files . --exclude-standard --others")
    .toString() !== "";

if (LOCAL_HAS_CHANGES) {
  console.log();
  console.log("=======================================================");
  console.log("WARNING: LOCAL CHANGES DETECTED");
  if (config.bottomLayerText.includeAutogeneratedInfo) {
    console.log("Autogenerated info will be disabled");
  }
  console.log("=======================================================");
  console.log();
}

fs.rmSync("./output", { recursive: true });
fs.mkdirSync("./output");
const cleanupTime = new Date();

const canvas = createCanvas(config.x, config.y);
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;
ctx.filter = "url(#crisp)";
ctx.antialias = "none";
const canvasTime = new Date();

const CURRENT_GIT_HASH =
  child_process.execSync("git rev-parse HEAD").toString().substring(0, 7) ||
  "GIT_HASH_NOT_FOUND";

const randomBetween = (min = 0, max = 1) => Math.random() * (max - min) + min;
const bezier = (t, p0, p1, p2, p3) => {
  const oneMinusT = 1 - t;
  return (
    Math.pow(oneMinusT, 3) * p0 +
    3 * Math.pow(oneMinusT, 2) * t * p1 +
    3 * oneMinusT * Math.pow(t, 2) * p2 +
    Math.pow(t, 3) * p3
  );
};

let randholder = null;

const orientBezier = (bezierConfig) => {
  let p0, p1, p2, p3;

  if (bezierConfig && bezierConfig.length === 4) {
    p0 = bezierConfig[0];
    p1 = 1 - bezierConfig[3];
    p2 = bezierConfig[2];
    p3 = 1 - bezierConfig[1];
  } else {
    p0 = 1;
    p1 = 1;
    p2 = 1;
    p3 = 1;
  }

  return [p0, p1, p2, p3];
};

const paintRandomNumbers = (randholder) => {
  if (config.paintRand) {
    // <Render random numbers to canvas>
    const SCALE = 80;
    const randholderCanvas = createCanvas(config.x * SCALE, config.y * SCALE);
    const randholderCtx = randholderCanvas.getContext("2d");
    // Print the numbers to the canvas

    for (let row = 0; row < config.y; row++) {
      for (let col = 0; col < config.x; col++) {
        randholderCtx.font = "25px Arial";
        randholderCtx.fillStyle = "#fff";
        randholderCtx.fillRect(col * SCALE, row * SCALE, SCALE, SCALE);
        randholderCtx.fillStyle = "#000000";
        randholderCtx.strokeRect(col * SCALE, row * SCALE, SCALE, SCALE);
        randholderCtx.fillText(
          randholder[col][row].toFixed(2),
          col * SCALE + 10,
          row * SCALE + 40
        );
        let progress;
        if (config.gradientDirection === "vertical") {
          progress = row / config.y;
        } else if (config.gradientDirection === "horizontal") {
          progress = col / config.x;
        }
        randholderCtx.font = "italic 15px Arial";
        randholderCtx.fillText(
          progress.toFixed(2),
          col * SCALE + 10,
          row * SCALE + 60
        );
        randholderCtx.fillStyle =
          randholder[col][row] > progress ? "red" : "green";
        randholderCtx.fillText(
          randholder[col][row] > progress ? "<" : ">",
          col * SCALE + 50,
          row * SCALE + 60
        );
      }
    }
    // Save the canvas to a file
    const randholderCanvasBuffer = randholderCanvas.toBuffer("image/png");
    fs.writeFileSync(
      `./output/slice_${String(i).padStart(3, "0")}_rand.png`,
      randholderCanvasBuffer
    );
    // </Render random numbers to canvas>
  }
};

const paintGradient = (randholder) => {
  for (let row = 0; row < config.y; row++) {
    for (let col = 0; col < config.x; col++) {
      let progress;
      if (config.gradientDirection === "vertical") {
        progress = row / config.y;
      } else if (config.gradientDirection === "horizontal") {
        progress = col / config.x;
      }
      if (progress > randholder[col][row]) {
        ctx.fillStyle = config.colors.cyan;
        ctx.fillRect(col, row, config.density, config.density);
      } else {
        ctx.fillStyle = config.colors.white;
        ctx.fillRect(col, row, config.density, config.density);
      }
    }
  }
};

function rgbToHsv(r, g, b) {
  (r /= 255), (g /= 255), (b /= 255);

  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    v = max;

  var d = max - min;
  s = max == 0 ? 0 : d / max;

  if (max == min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }

    h /= 6;
  }

  return [h, s, v];
}

function hueToCMY(hue) {
  hue = hue % 360; // Normalize the hue to be within 0-360 degrees
  let c = 0,
    m = 0,
    y = 0;

  if (hue < 60) {
    // Transition from red to yellow (magenta decreases)
    m = 1 - hue / 60;
    y = 1;
  } else if (hue < 180) {
    // Transition from yellow to cyan (yellow decreases, cyan increases)
    c = (hue - 60) / 120;
    y = 1 - c;
  } else if (hue < 300) {
    // Transition from cyan to magenta (cyan decreases, magenta increases)
    m = (hue - 180) / 120;
    c = 1 - m;
  } else {
    // Transition from magenta to red (yellow increases)
    y = (hue - 300) / 60;
    m = 1;
  }

  // Ensuring values are between 0 and 1
  c = Math.max(0, Math.min(1, c));
  m = Math.max(0, Math.min(1, m));
  y = Math.max(0, Math.min(1, y));

  return [c, m, y];
}

const paintSolidColor = (randholder) => {
  const colorInHsv = rgbToHsv(...config.color);
  const [cyanThreshold, magentaThreshold, yellowThreshold] = hueToCMY(
    colorInHsv[0] * 360
  );

  for (let row = 0; row < config.y; row++) {
    for (let col = 0; col < config.x; col++) {
      const whiteThreshold = Math.random();
      if (whiteThreshold > colorInHsv[1]) {
        const blackThreshold = Math.random();
        if (blackThreshold > colorInHsv[2]) {
          const randomNumberThreshold = Math.random();
          if (randomNumberThreshold < 0.33) {
            ctx.fillStyle = config.colors.cyan;
          } else if (randomNumberThreshold < 0.66) {
            ctx.fillStyle = config.colors.magenta;
          } else {
            ctx.fillStyle = config.colors.yellow;
          }
          // Paints black
        } else {
          ctx.fillStyle = config.colors.white;
        }
        ctx.fillRect(col, row, config.density, config.density);
      } else {
        if (randholder[col][row] < cyanThreshold) {
          ctx.fillStyle = config.colors.cyan;
          ctx.fillRect(col, row, config.density, config.density);
        } else if (randholder[col][row] < magentaThreshold) {
          ctx.fillStyle = config.colors.magenta;
          ctx.fillRect(col, row, config.density, config.density);
        } else if (randholder[col][row] < yellowThreshold) {
          ctx.fillStyle = config.colors.yellow;
          ctx.fillRect(col, row, config.density, config.density);
        } else {
          ctx.fillStyle = config.colors.white;
          ctx.fillRect(col, row, config.density, config.density);
        }
      }
    }
  }
};

const drawBottomLayerText = (returnBuffer, i) => {
  if (
    config.bottomLayerText.include &&
    i >= config.layers - config.bottomLayerText.layerCount &&
    !returnBuffer
  ) {
    ctx.font = `40px Arial`;
    ctx.fillStyle = config.bottomLayerText.color;
    let currentDate = new Date();
    let formattedDate = `${currentDate.getFullYear()}-${(
      currentDate.getMonth() + 1
    )
      .toString()
      .padStart(2, "0")}-${currentDate
      .getDate()
      .toString()
      .padStart(2, "0")} ${currentDate
      .getHours()
      .toString()
      .padStart(2, "0")}:${currentDate
      .getMinutes()
      .toString()
      .padStart(2, "0")}`;

    if (config.bottomLayerText.line1) {
      ctx.fillText(config.bottomLayerText.line1, 25, 25 + 50);
      ctx.fillText(
        `generator git hash: ${CURRENT_GIT_HASH}${
          LOCAL_HAS_CHANGES ? " [Δ]" : ""
        }`,
        25,
        25 + 50 + 50
      );
      ctx.fillText(`generated at: ${formattedDate}`, 25, 25 + 50 + 50 + 50);
    } else {
      ctx.fillText(
        `generator git hash: ${CURRENT_GIT_HASH}${
          LOCAL_HAS_CHANGES ? " [Δ]" : ""
        }`,
        25,
        25 + 50
      );
      ctx.fillText(`generated at: ${formattedDate}`, 25, 25 + 50 + 50);
    }
  }
};

const main = (i = 0, returnBuffer = false, bezierConfig) => {
  const starttime = new Date();

  let [p0, p1, p2, p3] = orientBezier(bezierConfig);

  if (!returnBuffer && config.useUniformRandom && randholder !== null) {
    console.log("using uniform random numbers");
  } else {
    console.log("generating random numbers");
    randholder = Array.from({ length: config.x }, () =>
      Array.from({ length: config.y }, () =>
        bezier(randomBetween(), p0, p1, p2, p3)
      )
    );
  }

  paintRandomNumbers(randholder);

  const randholderTime = new Date();

  // paintGradient(randholder);
  paintSolidColor(randholder);

  drawBottomLayerText(returnBuffer, i);

  const drawTime = new Date();

  const buffer = canvas.toBuffer("image/png");
  if (returnBuffer) return buffer;

  fs.writeFileSync(`./output/slice_${String(i).padStart(3, "0")}.png`, buffer);

  const endtime = new Date();
  const time = endtime - starttime;
  console.log(
    `saved ${i}.png in ${time} ms. [rand, draw, export] [${
      randholderTime - starttime
    }ms, ${drawTime - randholderTime} ms, ${endtime - drawTime} ms] [${
      randholderTime - starttime
    } ${drawTime - randholderTime} ${endtime - drawTime}]`
  );
};

const loop = (bezierConfig = [0, 0, 1, 1]) => {
  fs.rmSync("./output", { recursive: true });
  fs.mkdirSync("./output");
  for (let i = 0; i < config.layers; i++) {
    main(i, false, bezierConfig);
  }
};

if (require.main === module) {
  loop();
}

const overallTimeEnd = new Date();
const overallTime = overallTimeEnd - overallTimeStart;
console.log(`finished in ${overallTime} ms (${overallTime / 1000} s)`);

module.exports = { main, loop };
